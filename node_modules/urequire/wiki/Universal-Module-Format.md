With uRequire, your modules can be either written in AMD:

```js
// standard anonymous module format
define(['dep1', 'dep2'], function(dep1, dep2) {
   // do stuff with dep1, dep2
   return {my:'module'}
});

// or a named module
define('moduleName', ['dep1', 'dep2'], function(dep1, dep2) {...});

// or a module without *array* dependencies
define(function() {...})
```

or in the CommonJs/nodejs format:

```js
var dep1 = require('dep1');
var dep2 = require('dep2');

// do stuff with dep1, dep2
module.exports = {my: 'module'}
```
or a *relaxed** combination of both:

```js
// uRequire relaxed notation
define(['dep1', 'dep2'], function(dep1, dep2) {
   var dep3 = require('dep3');
   // do stuff with dep1, dep2, dep3
   return {my:'module'}
});
```
 * *relaxed means you dont need to be strict to either standard, but also it would NOT work as a plain AMD/nodejs module without uRequire conversion.*

uRequire guarantees that your modules are correctly translated and execute on both target environments, even though the easier, *less verbose* and *relaxed* format is used.

The idiosyncrasies and limitations of module formats are waived, so you can focus on what is important: you modular code that can be expressed in the easiest sensible way possible.

For instance you can use both the syntax of [synchronous](synchronous-require) & [asynchronous](asynchronous-require) require, mix [absolute/bundleRelative with fileRelative](flexible-path-conventions#bundlerelative-vs-filerelative-paths) paths, forget about requiring [`require` or `module`/`exports`](synchronous-require#no-more-require-module-exports-declarations) and just be sure that your code will [execute on both runtimes](deployment) in a consistent way.

## Future

In the future other modules formats like [ES6 harmony:modules](http://wiki.ecmascript.org/doku.php?id=harmony:modules) can be used as source or target. But that is only a tiny point of [future directions of uRequire](Future-Directions).
