*The hasty coder intro*

### Why ?

The main drive behind uRequire is to enable you to :

 * author **boilerplate-free** *modular javascript code* once and DRY.
 
 * seamlessly execute (& test it) everywhere (i.e **browser** & **nodejs**).

### Wheels are turning 

**uRequire isnt reinventing the wheel**. Its not proposing yet another modules system or a non standard bloated way to stitch code together. Its premise is build on **standard exisitng technologies**, namely CommonJS (i.e nodejs `require('')`) and AMD (i.e RequireJS `define([], fn)`).

With a simple build step, uRequire converts your modules to UMD (or AMD, nodejs or 'combined.js') using static code analysis, a code generation template system and build/runtime dependency path resolution along with other build & runtime goodies.

### How ?

Your source can be written either in the 'strict' AMD format `define([], function(){})` or the nodejs/commonjs `require('dep')`.

But, you can also use a *relaxed* or *hybrid* [Universal Module Format](Universal-Module-Format), for example using asynchronous `require([], fn)`s everywhere) and extra kinky features.

uRequire converts it to suitable UMD (or other) format that can be deployed everywhere.

But it does more than just converting modules `{from: ['AMD', 'commonjs'], to: ['AMD', 'commonjs', 'UMD', '<script>']}` - keep reading.

## Extras ? Kinky ?

 * Simple & standards based syntax, without any need for UMD or other boilerplate.

 * Transparent [path translations](flexible-path-conventions), eg from `../../../PersonModel` to `data/PersonModel`.

 * Freely use [synchronous `require('mylib')`](synchronous-require) **on AMD** and asynchronous calls [`require(['...'], function(){...})`](asynchronous-require) **on nodejs**.

 * Never miss a `require('')` declaration on `define([],...)` that [halts your app](synchronous-require#never-miss-a-dependency).

 * You can use [RequireJS loader plugins](requirejs-loader-plugins) **on nodejs**.

 * Declaratively export modules to [`root`/`global`/`window`](exporting-modules#simplified-rootexports), with a [`noConflict()`](exporting-modules#generated-noconflict-functionality) or have [dependencies injected](masterdefaultsconfig.coffee#bundle.dependencies.exports.bundle) in all modules etc.

 * Build to a single `combined.js` via the [`combined` template](combined-template), and have it run everywhere (nodejs and even a browser *without* an AMD loader) **without any dependencies**.

 * A flexible & extendible **Modules & Dependencires aware** [Resource Conversion](ResourceConverters.coffee) subsystem, with an **in-memory only-when-needed workflow** like no other.

 * [Manipulate modules](resourceconverters.coffee#manipulate-replace-ast-code) at build stage: inject, replace or remove dependencies, alter or remove code and more.

**`{"uDeclare": "uRequire does all this magic for you."}`**