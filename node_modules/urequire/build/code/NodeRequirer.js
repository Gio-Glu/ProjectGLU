// Generated by uRequire v0.7.0-beta.23 target: 'lib' template: 'nodejs'

var _ = require('lodash'),
    _B = require('uberscore'),
    UError = require('./utils/UError');

var l = new _B.Logger('uRequire/NodeRequirer');

var BundleBase, Dependency, NodeRequirer, fs, pathRelative, upath, urequire, util, bind = function (fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  }, extend = function (child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  };
fs = require("fs");
upath = require("upath");
util = require("util");
pathRelative = require("./paths/pathRelative");
Dependency = require("./fileResources/Dependency");
urequire = require("./urequire");
BundleBase = require("./process/BundleBase");
NodeRequirer = function (superClass) {
  var unloaded;
  extend(NodeRequirer, superClass);
  function NodeRequirer(moduleNameBR, modyle, moduleRequire, dirname, webRootMap, debugLevel) {
    var baseUrl;
    this.moduleNameBR = moduleNameBR;
    this.modyle = modyle;
    this.moduleRequire = moduleRequire;
    this.dirname = dirname;
    this.webRootMap = webRootMap;
    this.require = bind(this.require, this);
    this.loadModule = bind(this.loadModule, this);
    this.l = new _B.Logger("uRequire/NodeRequirer `" + this.moduleNameBR + "`}", debugLevel);
    this.path = upath.normalize(this.dirname + "/" + pathRelative("" + upath.dirname(this.moduleNameBR), ".", { assumeRoot: true }) + "/");
    if (this.l.deb(30)) {
      this.l.deb("\n\n`new NodeRequirer()` instanciating\n      @moduleNameBR = '" + this.moduleNameBR + "'\n      @modyle.id = '" + this.modyle.id + "'\n      @dirname = '" + this.dirname + "'\n      @webRootMap = '" + this.webRootMap + "')\n      @path = '" + this.path + "'");
    }
    if (this.getRequireJSConfig().baseUrl) {
      baseUrl = this.getRequireJSConfig().baseUrl;
      if (this.l.deb(15)) {
        this.l.deb("`baseUrl` (from requireJsConfig ) = " + baseUrl);
      }
      this.path = upath.normalize((baseUrl[0] === "/" ? this.webRoot : this.path) + "/" + baseUrl + "/");
      if (this.l.deb(30)) {
        this.l.deb("Final `@path` (from requireJsConfig.baseUrl & @path) = " + this.path);
      }
    }
  }
  Object.defineProperties(NodeRequirer.prototype, {
    nodeRequire: {
      get: function () {
        return this._nodeRequire || _.bind(this.modyle.require, this.modyle);
      },
      set: function (_nodeRequire) {
        this._nodeRequire = _nodeRequire;
      }
    },
    debugInfo: {
      get: function () {
        var config, di, pathsRjs, pathsRjsConfig, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, rjs, rjsConfig, rjsConfigs, rjsLoaded;
        di = {
          path: this.path,
          webRoot: this.webRoot
        };
        rjsLoaded = di["requirejsLoaded[@path]"] = {};
        ref = NodeRequirer.prototype.requirejsLoaded;
        for (pathsRjs in ref) {
          rjs = ref[pathsRjs];
          rjsConfig = rjsLoaded[pathsRjs] = {};
          rjsConfig["requirejs._.config.baseUrl"] = (ref1 = rjs.s) != null ? (ref2 = ref1.contexts) != null ? (ref3 = ref2._) != null ? ref3.config.baseUrl : void 0 : void 0 : void 0;
          rjsConfig["requirejs._.config.paths"] = (ref4 = rjs.s) != null ? (ref5 = ref4.contexts) != null ? (ref6 = ref5._) != null ? ref6.config.paths : void 0 : void 0 : void 0;
        }
        rjsConfigs = di["requireJSConfigs[@path]"] = {};
        ref7 = NodeRequirer.prototype.requireJSConfigs;
        for (pathsRjsConfig in ref7) {
          config = ref7[pathsRjsConfig];
          rjsConfigs[pathsRjsConfig] = config;
        }
        return this.l.prettify(di);
      }
    },
    requirejs: {
      get: function () {
        var base, base1, i, j, len, len1, pathEntries, pathEntry, pathName, ref, ref1, requireJsConf, requirejs, resolvedPath;
        if ((base = NodeRequirer.prototype).requirejsLoaded == null) {
          base.requirejsLoaded = {};
        }
        if (!NodeRequirer.prototype.requirejsLoaded[this.path]) {
          requirejs = this.nodeRequire("requirejs");
          requireJsConf = {
            nodeRequire: this.nodeRequire,
            baseUrl: this.path
          };
          if (this.getRequireJSConfig().paths) {
            requireJsConf.paths = {};
            ref = this.getRequireJSConfig().paths;
            for (pathName in ref) {
              pathEntries = ref[pathName];
              pathEntries = _B.arrayize(pathEntries);
              (base1 = requireJsConf.paths)[pathName] || (base1[pathName] = []);
              for (i = 0, len = pathEntries.length; i < len; i++) {
                pathEntry = pathEntries[i];
                ref1 = this.resolvePaths(new Dependency(pathEntry), this.path);
                for (j = 0, len1 = ref1.length; j < len1; j++) {
                  resolvedPath = ref1[j];
                  if (!(indexOf.call(requireJsConf.paths[pathName], resolvedPath) >= 0)) {
                    requireJsConf.paths[pathName].push(resolvedPath);
                  }
                }
              }
            }
          }
          requirejs.config(requireJsConf);
          NodeRequirer.prototype.requirejsLoaded[this.path] = requirejs;
        }
        return NodeRequirer.prototype.requirejsLoaded[this.path];
      }
    }
  });
  NodeRequirer.prototype.getRequireJSConfig = function () {
    var base, base1, err, error, error1, name, rjsc;
    if ((base = NodeRequirer.prototype).requireJSConfigs == null) {
      base.requireJSConfigs = {};
    }
    if (NodeRequirer.prototype.requireJSConfigs[this.path] === void 0) {
      try {
        rjsc = require("fs").readFileSync(this.path + "requirejs.config.json", "utf-8");
      } catch (error) {
      }
      if (rjsc) {
        try {
          NodeRequirer.prototype.requireJSConfigs[this.path] = JSON.parse(rjsc);
        } catch (error1) {
          err = error1;
          throw new UError("urequire: error parsing requirejs.config.json from " + (this.path + "requirejs.config.json"), { nested: err });
        }
      }
      if ((base1 = NodeRequirer.prototype.requireJSConfigs)[name = this.path] == null) {
        base1[name] = {};
      }
    }
    return NodeRequirer.prototype.requireJSConfigs[this.path];
  };
  unloaded = {};
  NodeRequirer.prototype.loadModule = function (dep) {
    var att, attIdx, attempts, err, error, error1, hasPlugin, i, j, len, len1, loadedModule, modulePath, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, requirer, requirers, resolvedPathNo, resolvedPaths;
    attempts = [];
    loadedModule = unloaded;
    this.l.deb(95, "called `loadModule('" + dep + "')`");
    resolvedPaths = this.resolvePaths(dep, this.dirname);
    if (this.l.deb(95)) {
      this.l.deb("resolvedPaths = \n", resolvedPaths);
    }
    requirers = (hasPlugin = (ref = (ref1 = dep.plugin) != null ? typeof ref1.name === "function" ? ref1.name() : void 0 : void 0) !== void 0 && ref !== "node") ? ["requirejs"] : [
      "nodeRequire",
      "requirejs"
    ];
    for (i = 0, len = requirers.length; i < len; i++) {
      requirer = requirers[i];
      for (resolvedPathNo = j = 0, len1 = resolvedPaths.length; j < len1; resolvedPathNo = ++j) {
        modulePath = resolvedPaths[resolvedPathNo];
        if (hasPlugin) {
          modulePath = dep.pluginName + "!" + modulePath;
        }
        if (this.l.deb(50)) {
          this.l.deb(50, "resolvedPathNo #" + resolvedPathNo + ": '" + modulePath + "'");
          if (this.l.deb(70) && requirer === "nodeRequire") {
            try {
              this.l.deb("@moduleRequire.resolve() = `" + this.moduleRequire.resolve(modulePath) + "`");
            } catch (error) {
            }
          }
        }
        attempts.push({
          resolvedPathNo: resolvedPathNo,
          modulePath: modulePath,
          requirerUsed: requirer,
          dependency: dep.name()
        });
        if (this.l.deb(30)) {
          this.l.deb("ISSUING: " + requirer + "('" + modulePath + "')");
        }
        try {
          loadedModule = this[requirer](modulePath);
        } catch (error1) {
          err = error1;
          if (this.l.deb(30)) {
            this.l.warn("FAILED: `@" + requirer + "('" + modulePath + "')` err=\n", err);
          }
          if (requirer === "requirejs") {
            this.requirejs.undef(modulePath);
          }
          _.extend(_.last(attempts), {
            urequireError: "Error loading module through requirer `" + requirer + "`.",
            error: {
              string: err.toString(),
              err: err
            }
          });
          if (hasPlugin) {
            _.extend(_.last(attempts), {
              pluginName: dep.pluginName,
              pluginPaths: (ref2 = this.requireJSConfig) != null ? ref2.paths[dep.pluginName] : void 0,
              pluginResolvedPaths: (ref3 = this.requirejs) != null ? (ref4 = ref3.s) != null ? (ref5 = ref4.contexts) != null ? (ref6 = ref5._) != null ? (ref7 = ref6.config) != null ? ref7.paths[dep.pluginName] : void 0 : void 0 : void 0 : void 0 : void 0
            });
          }
        }
        if (loadedModule !== unloaded) {
          break;
        }
      }
      if (loadedModule !== unloaded) {
        break;
      }
    }
    if (loadedModule === unloaded) {
      this.l.er("\n\n*uRequire " + urequire.VERSION + "*: failed to load dependency: '" + dep + "' in module '" + this.moduleNameBR + "'.\nTried paths:\n" + _.uniq(function () {
        var k, len2, results;
        results = [];
        for (k = 0, len2 = attempts.length; k < len2; k++) {
          att = attempts[k];
          results.push("'" + att.modulePath + "'");
        }
        return results;
      }()).join("\n  ") + "\n\nQuiting with throwing 1st error at the end - Detailed attempts follow:\n" + function () {
        var k, len2, results;
        results = [];
        for (attIdx = k = 0, len2 = attempts.length; k < len2; attIdx = ++k) {
          att = attempts[attIdx];
          results.push("  [33m Attempt #" + (attIdx + 1) + "\n" + this.l.prettify(att));
        }
        return results;
      }.call(this).join("\n\n") + "\n\nDebug info:\n ", this.debugInfo);
      throw ((ref8 = attempts[0]) != null ? (ref9 = ref8.error) != null ? ref9.err : void 0 : void 0) || "1st err was undefined!";
    } else {
      if (this.l.deb(20)) {
        this.l.ok("`@" + requirer + "` loaded dep `" + dep + "` from `" + modulePath + "` (resolvedPathNo #" + resolvedPathNo + ") ");
      }
      return loadedModule;
    }
  };
  NodeRequirer.prototype.require = function (strDeps, callback) {
    if (_.isString(strDeps)) {
      if (this.l.deb(80)) {
        this.l.deb("`nr.require('" + strDeps + "')` called - @loadModule synchronously single dep.");
      }
      return this.loadModule(new Dependency(strDeps, { path: this.moduleNameBR }));
    } else {
      if (_.isArray(strDeps) && _.isFunction(callback)) {
        if (this.l.deb(50)) {
          this.l.deb("`nr.require(" + util.inspect(strDeps) + ")` called: @loadModule called asynchronously for each dep in array.");
        }
        return process.nextTick(function (_this) {
          return function () {
            var strDep;
            return callback.apply(null, function () {
              var i, len, results;
              results = [];
              for (i = 0, len = strDeps.length; i < len; i++) {
                strDep = strDeps[i];
                results.push(this.loadModule(new Dependency(strDep, { path: this.moduleNameBR })));
              }
              return results;
            }.call(_this));
          };
        }(this));
      }
    }
  };
  return NodeRequirer;
}(BundleBase);
module.exports = NodeRequirer;

;