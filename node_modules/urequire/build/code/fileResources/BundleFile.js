// Generated by uRequire v0.7.0-beta.23 target: 'lib' template: 'nodejs'

var _ = require('lodash'),
    _B = require('uberscore'),
    UError = require('../utils/UError');

var l = new _B.Logger('uRequire/fileResources/BundleFile');

var BundleFile, When, fs, isTrueOrFileMatch, mkdirp, pathRelative, upath;
fs = require("fs");
mkdirp = require("mkdirp");
When = require("when");
upath = require("upath");
isTrueOrFileMatch = require("../config/isTrueOrFileMatch");
pathRelative = "../paths/pathRelative";
BundleFile = function () {
  var bof, fn, i, len, ref;
  ref = [
    "clean",
    "deleteErrored"
  ];
  fn = function (bof) {
    return Object.defineProperty(BundleFile.prototype, "is" + _.capitalize(bof), {
      get: function () {
        var ref1, ref2;
        return isTrueOrFileMatch((ref1 = this.bundle) != null ? (ref2 = ref1.build) != null ? ref2[bof] : void 0 : void 0, this.dstFilename);
      }
    });
  };
  for (i = 0, len = ref.length; i < len; i++) {
    bof = ref[i];
    fn(bof);
  }
  function BundleFile(data) {
    _.extend(this, data);
    this.dstFilename = this.srcFilename;
  }
  BundleFile.prototype.refresh = When.lift(function () {
    var statProps, stats;
    if (!this.srcExists) {
      throw new UError("BundleFile missing '" + this.srcFilepath + "'");
    } else {
      stats = _.pick(fs.statSync(this.srcFilepath), statProps = [
        "mtime",
        "size"
      ]);
      if (!_.isEqual(stats, this.fileStats)) {
        this.fileStats = stats;
        return this.hasChanged = true;
      } else {
        l.verbose("No changes in " + l.prettify(statProps) + " of file '" + this.srcFilename + "'");
        return this.hasChanged = false;
      }
    }
  });
  BundleFile.prototype.reset = function () {
    delete this.fileStats;
    delete this.hasErrors;
    return this.dstFilename = this.srcFilename;
  };
  BundleFile.prototype.clean = function () {
    var err, error, filenames, fname, j, len1, ref1, results;
    filenames = this.dstFilenamesSaved || [this.dstFilename];
    ref1 = _.map(filenames, function (_this) {
      return function (f) {
        return upath.join(_this.dstPath, f);
      };
    }(this));
    results = [];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      fname = ref1[j];
      if (!fs.existsSync(fname)) {
        results.push(l.deb(30, "clean: Not existing file '" + fname + "' - cant delete!."));
      } else {
        l.verbose("clean: Deleting file: " + fname);
        try {
          results.push(fs.unlinkSync(fname));
        } catch (error) {
          err = error;
          results.push(l.er("clean: Cant delete file '" + fname + "'.", err));
        }
      }
    }
    return results;
  };
  Object.defineProperties(BundleFile.prototype, {
    extname: {
      get: function () {
        return upath.extname(this.srcFilename);
      }
    },
    srcFilepath: {
      get: function () {
        var ref1;
        return upath.join(((ref1 = this.bundle) != null ? ref1.path : void 0) || "", this.srcFilename);
      }
    },
    srcRealpath: {
      get: function () {
        return process.cwd() + "/" + this.srcFilepath;
      }
    },
    srcExists: {
      get: function () {
        return fs.existsSync(this.srcFilepath);
      }
    },
    dstPath: {
      get: function () {
        var ref1, ref2;
        return ((ref1 = this.bundle) != null ? (ref2 = ref1.build) != null ? ref2.dstPath : void 0 : void 0) || "";
      }
    },
    dstFilepath: {
      get: function () {
        return upath.join(this.dstPath, this.dstFilename);
      }
    },
    dstRealpath: {
      get: function () {
        return process.cwd() + "/" + this.dstFilepath;
      }
    },
    dstExists: {
      get: function () {
        if (this.dstFilepath) {
          return fs.existsSync(this.dstFilepath);
        }
      }
    },
    pathToRoot: {
      get: function () {
        return pathRelative(upath.dirname(this.path), "/", { assumeRoot: true });
      }
    },
    sourceMapInfo: {
      get: function () {
        return {
          file: upath.basename(this.dstFilepath),
          sourceRoot: upath.dirname(upath.relative(upath.dirname(this.dstFilepath), this.srcFilepath)),
          sources: [upath.basename(this.srcFilepath)],
          sourceMappingURL: "/*\n//@ sourceMappingURL=" + upath.basename(this.dstFilepath) + ".map\n*/"
        };
      }
    }
  });
  BundleFile.prototype.copy = function (srcFilename, dstFilename) {
    var ref1, ref2, ref3;
    if (srcFilename == null) {
      srcFilename = this.srcFilename;
    }
    if (dstFilename == null) {
      dstFilename = this.dstFilename;
    }
    return BundleFile.copy(upath.join(((ref1 = this.bundle) != null ? ref1.path : void 0) || "", srcFilename), upath.join(((ref2 = this.bundle) != null ? (ref3 = ref2.build) != null ? ref3.dstPath : void 0 : void 0) || "", dstFilename));
  };
  BundleFile.copy = function (srcFile, dstFile, overwrite) {
    var BUF_LENGTH, buff, bytesRead, compStats, dstFileDirname, err, error, fdr, fdw, pos, srcStats;
    if (overwrite == null) {
      overwrite = "DUMMY";
    }
    if (!fs.existsSync(srcFile)) {
      throw new UError("copy: source file missing '" + srcFile + "'");
    } else {
      srcStats = _.pick(fs.statSync(srcFile), [
        "atime",
        "mtime",
        "size"
      ]);
      if (fs.existsSync(dstFile)) {
        compStats = [
          "mtime",
          "size"
        ];
        if (_.isEqual(_.pick(srcStats, compStats), _.pick(fs.statSync(dstFile), compStats))) {
          if (l.deb(80)) {
            l.debug("NOT copying same: srcFile='" + srcFile + "', dstFile='" + dstFile + "'");
          }
          return false;
        }
      }
    }
    if (l.deb(40)) {
      l.debug("copy {src='" + srcFile + "', dst='" + dstFile + "'}");
    }
    try {
      BUF_LENGTH = 64 * 1024;
      buff = new Buffer(BUF_LENGTH);
      fdr = fs.openSync(srcFile, "r");
      if (!fs.existsSync(dstFileDirname = upath.dirname(dstFile))) {
        l.verbose("copy: Creating directory " + dstFileDirname);
        mkdirp.sync(dstFileDirname);
      }
      fdw = fs.openSync(dstFile, "w");
      bytesRead = 1;
      pos = 0;
      while (bytesRead > 0) {
        bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
        fs.writeSync(fdw, buff, 0, bytesRead);
        pos += bytesRead;
      }
      fs.closeSync(fdr);
      fs.closeSync(fdw);
      fs.utimesSync(dstFile, srcStats.atime, srcStats.mtime);
      return true;
    } catch (error) {
      err = error;
      throw new UError("copy: Error copying from '" + srcFile + "' to '" + dstFile + "'", { nested: err });
    }
  };
  BundleFile.requireClean = require("require-clean");
  BundleFile.prototype.requireClean = function (name) {
    if (name == null) {
      name = this.srcRealpath;
    }
    return BundleFile.requireClean(name);
  };
  BundleFile.prototype.inspect = function () {
    var inspectText;
    inspectText = " " + this.constructor.name + " : '" + this.dstFilename + "' ";
    if (this.hasChanged) {
      inspectText += "[32;1m(hasChanged)[0m";
    }
    if (this.hasErrors) {
      inspectText += "[31;1m(hasErrors)[0m";
    }
    return inspectText;
  };
  return BundleFile;
}();
module.exports = BundleFile;
_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});

;