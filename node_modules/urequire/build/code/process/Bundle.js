// Generated by uRequire v0.7.0-beta.23 target: 'lib' template: 'nodejs'

var _ = require('lodash'),
    _B = require('uberscore'),
    UError = require('../utils/UError');

var l = new _B.Logger('uRequire/process/Bundle');

var Build, Bundle, BundleBase, BundleFile, CodeMerger, DependenciesReporter, Dependency, FileResource, MasterDefaultsConfig, Module, ResourceConverterError, TextResource, When, bower, dependenciesBindingsBlender, err, error1, execP, fs, globExpand, ref, shimBlender, toCode, umatch, upath, extend = function (child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  };
_.mixin(require("underscore.string").exports());
fs = require("fs");
globExpand = require("glob-expand");
umatch = require("umatch");
upath = require("upath");
When = require("../promises/whenFull");
execP = When.node.lift(require("child_process").exec);
try {
  bower = require("bower");
} catch (error1) {
  err = error1;
}
MasterDefaultsConfig = require("../config/MasterDefaultsConfig");
Dependency = require("../fileResources/Dependency");
DependenciesReporter = require("../utils/DependenciesReporter");
ResourceConverterError = require("../utils/ResourceConverterError");
BundleFile = require("../fileResources/BundleFile");
FileResource = require("../fileResources/FileResource");
TextResource = require("../fileResources/TextResource");
Module = require("../fileResources/Module");
Build = require("./Build");
BundleBase = require("./BundleBase");
CodeMerger = require("../codeUtils/CodeMerger");
toCode = require("../codeUtils/toCode");
ref = require("../config/blendConfigs"), shimBlender = ref.shimBlender, dependenciesBindingsBlender = ref.dependenciesBindingsBlender;
Bundle = function (superClass) {
  var isCalcPropDepsVars, isCalcPropFiles, localPathsCacheFile;
  extend(Bundle, superClass);
  function Bundle(bundleCfg) {
    Bundle.__super__.constructor.apply(this, arguments);
    _.extend(this, bundleCfg);
    this.files = {};
  }
  Bundle.prototype.inspect = function () {
    return "Bundle:" + l.prettify({
      target: this.target,
      name: this.name,
      main: this.main,
      path: this.path,
      filez: this.filez,
      files: this.files
    });
  };
  isCalcPropDepsVars = function (p) {
    return _(p).endsWith("depsVars");
  };
  isCalcPropFiles = function (p) {
    return p === "filenames" || p === "dstFilenames" || p === "fileResources" || p === "textResources" || p === "modules" || p === "copyFiles" || p === "errorFiles";
  };
  Bundle.calcProperties = {
    filenames: function () {
      if (_.isEmpty(this.files)) {
        return _.filter(globExpand({
          cwd: this.path,
          filter: "isFile"
        }, "**/*"), function (_this) {
          return function (f) {
            return umatch(f, _this.filez);
          };
        }(this));
      } else {
        return _.keys(this.files);
      }
    },
    dstFilenames: function () {
      return _.reduce(this.files, function (fnames, f) {
        var fn, j, len, ref1;
        fnames.push(f.dstFilename);
        if (_.size(f.dstFilenamesSaved) > 1) {
          ref1 = f.dstFilenamesSaved;
          for (j = 0, len = ref1.length; j < len; j++) {
            fn = ref1[j];
            if (fn !== f.dstFilename) {
              fnames.push(fn);
            }
          }
        }
        return fnames;
      }, []);
    },
    mainModule: function () {
      var j, len, mainCand, mainMod, ref1;
      if (this.main) {
        mainMod = _.find(this.modules, function (_this) {
          return function (m) {
            return m.path === _this.main;
          };
        }(this));
      } else {
        if (_.size(this.modules) === 1) {
          mainMod = _.find(this.modules);
        } else {
          ref1 = [
            this.name,
            "index",
            "main"
          ];
          for (j = 0, len = ref1.length; j < len; j++) {
            mainCand = ref1[j];
            if (!mainCand) {
              continue;
            }
            mainMod = _.find(this.modules, function (m) {
              return m.path === mainCand;
            });
            if (mainMod) {
              break;
            }
          }
        }
      }
      return mainMod;
    },
    fileResources: function () {
      return _.pick(this.files, function (f) {
        return f instanceof FileResource;
      });
    },
    textResources: function () {
      return _.pick(this.files, function (f) {
        return f instanceof TextResource;
      });
    },
    modules: function () {
      return _.pick(this.files, function (f) {
        return f instanceof Module;
      });
    },
    errorFiles: function () {
      return _.pick(this.files, function (f) {
        return f.hasErrors;
      });
    },
    modules_depsVars: function () {
      return this.inferEmptyDepVars(this.getModules_depsVars(), "modules_depsVars", false);
    },
    modules_localNonNode_depsVars: function () {
      return this.inferEmptyDepVars(this.getModules_depsVars(function (dep) {
        return dep.isLocal && !dep.isNode;
      }), "modules_localNonNode_depsVars");
    },
    modules_localNode_depsVars: function () {
      return this.inferEmptyDepVars(this.getModules_depsVars(function (dep) {
        return dep.isLocal && dep.isNode;
      }), "modules_localNode_depsVars", false);
    },
    modules_local_depsVars: function () {
      return dependenciesBindingsBlender.blend({}, this.modules_localNonNode_depsVars, this.modules_localNode_depsVars);
    },
    modules_node_depsVars: function () {
      return this.inferEmptyDepVars(this.getModules_depsVars(function (dep) {
        return dep.isNode;
      }), "modules_node_depsVars", false);
    },
    imports_depsVars: function () {
      return this.inferEmptyDepVars(this.getImports_depsVars(), "imports_depsVars");
    },
    imports_nonNode_depsVars: function () {
      return this.inferEmptyDepVars(this.getImports_depsVars(function (d) {
        return !d.isNode;
      }), "imports_nonNode_depsVars");
    },
    imports_bundle_depsVars: function () {
      return this.inferEmptyDepVars(this.getImports_depsVars(function (d) {
        return d.isBundle;
      }), "imports_bundle_depsVars");
    },
    imports_local_nonNode_depsVars: function () {
      return this.inferEmptyDepVars(this.getImports_depsVars(function (d) {
        return d.isLocal && !d.isNode;
      }), "imports_local_nonNode_depsVars");
    },
    local_depsVars: function () {
      return dependenciesBindingsBlender.blend({}, this.modules_local_depsVars, this.getImports_depsVars(function (d) {
        return d.isLocal;
      }));
    },
    local_nonNode_depsVars: function () {
      return dependenciesBindingsBlender.blend({}, this.modules_localNonNode_depsVars, this.getImports_depsVars(function (d) {
        return d.isLocal && !d.isNode;
      }));
    },
    local_node_depsVars: function () {
      return dependenciesBindingsBlender.blend({}, this.modules_localNode_depsVars, this.getImports_depsVars(function (d) {
        return d.isLocal && d.isNode;
      }));
    },
    nonImports_local_depsVars: function () {
      return _.pick(this.modules_local_depsVars, function (_this) {
        return function (vars, dep) {
          return !_this.dependencies.imports[dep];
        };
      }(this));
    },
    all_depsVars: function () {
      var allDepVarObjs, depVarObjectPaths, depVarsPath;
      depVarObjectPaths = _.map([
        "depsVars",
        "rootExports"
      ], function (v) {
        return "dependencies." + v;
      }).concat([
        "modules_depsVars",
        "imports_depsVars"
      ]);
      (allDepVarObjs = function () {
        var j, len, results;
        results = [];
        for (j = 0, len = depVarObjectPaths.length; j < len; j++) {
          depVarsPath = depVarObjectPaths[j];
          results.push(_B.getp(this, depVarsPath, { separator: "." }));
        }
        return results;
      }.call(this)).unshift({});
      return dependenciesBindingsBlender.blend.apply(null, allDepVarObjs);
    }
  };
  Bundle.prototype.getModules_depsVars = function (depFltr) {
    var k, mod;
    if (depFltr == null) {
      depFltr = function () {
        return true;
      };
    }
    return dependenciesBindingsBlender.blend.apply(null, function () {
      var ref1, results;
      ref1 = this.modules;
      results = [];
      for (k in ref1) {
        mod = ref1[k];
        results.push(mod.getDepsVars(depFltr));
      }
      return results;
    }.call(this));
  };
  Bundle.prototype.getImports_depsVars = function (depFltr) {
    if (depFltr == null) {
      depFltr = function () {
        return true;
      };
    }
    return _.pick(this.dependencies.imports, function (_this) {
      return function (vars, dep) {
        return depFltr(new Dependency(dep, _.find(_this.modules)));
      };
    }(this));
  };
  Bundle.prototype.inferEmptyDepVars = function (depVars, whereFrom, throwOnMissing) {
    var aVar, depName, depVarsPath, dependenciesDepsVars, j, len, len1, len2, n, o, ref1, ref2, ref3, whyMessage;
    if (depVars == null) {
      depVars = {};
    }
    if (throwOnMissing == null) {
      throwOnMissing = true;
    }
    whyMessage = "infer empty depVars (" + (throwOnMissing ? "MANDATORY" : "OPTIONAL") + ") for `@" + (whereFrom || "UNKNOWN") + "`.";
    if (!_.isEmpty(depVars) && l.deb(80)) {
      l.debug(whyMessage, "depVars = \n", depVars);
    }
    for (depName in depVars) {
      if (_.isEmpty(depVars[depName] || (depVars[depName] = []))) {
        l.deb(80, "inferEmptyDepVars : Dependency '" + depName + "' has no corresponding parameters/variable names to bind with.");
        ref1 = this.getModules_depsVars(function (dep) {
          return dep.name({ relative: "bundle" }) === depName;
        })[depName] || [];
        for (j = 0, len = ref1.length; j < len; j++) {
          aVar = ref1[j];
          if (indexOf.call(depVars[depName], aVar) < 0) {
            depVars[depName].push(aVar);
          }
        }
        if (l.deb(80)) {
          l.deb("inferEmptyDepVars: Dependency '" + depName + "', inferred varNames from bundle's Modules: ", depVars[depName]);
        }
        if (_.isEmpty(depVars[depName])) {
          ref2 = _.map([
            "depsVars",
            "_knownDepsVars",
            "imports",
            "rootExports"
          ], function (v) {
            return "dependencies." + v;
          });
          for (n = 0, len1 = ref2.length; n < len1; n++) {
            depVarsPath = ref2[n];
            dependenciesDepsVars = _B.getp(this, depVarsPath, { separator: "." });
            if (!_.isEmpty(dependenciesDepsVars != null ? dependenciesDepsVars[depName] : void 0) && depVars[depName] !== dependenciesDepsVars[depName]) {
              l.warn(whyMessage + ":\n", "Picking var bindings for `" + depName + "` from `@" + depVarsPath + "`", dependenciesDepsVars[depName]);
              ref3 = dependenciesDepsVars[depName];
              for (o = 0, len2 = ref3.length; o < len2; o++) {
                aVar = ref3[o];
                if (indexOf.call(depVars[depName], aVar) < 0) {
                  depVars[depName].push(aVar);
                }
              }
            }
          }
        }
      }
      if (throwOnMissing && _.isEmpty(depVars[depName])) {
        this.handleError(new UError("No variable names can be identified for injected or local or node-only dependency '" + depName + "'.\n\nThese variable names are used to :\n  - inject the dependency into each module\n    OR\n  - grab the dependency from the `window` object, when running as <script> via the 'combined' template.\n\nRemedy:\n\nIf you are injecting eg. at uRequire's config 'bundle.dependencies.imports', you 'd better declare it as:\n  ```\n    dependencies: imports: {\n      '" + depName + "': 'VARIABLE(S)_IT_BINDS_WITH',\n      ...\n      jquery: ['$', 'jQuery'],  // Array of known bindings\n      backbone: 'Backbone'      // A String will also do\n    }\n  ```\ninstead of the simpler\n  ```\n    dependencies: imports: [ '" + depName + "', ...., 'jquery', 'backbone' ]\n  ```\n\nAlternativelly, pick one medicine :\n  - define at least one module that has this dependency + variable binding (either as AMD or commonJs) and uRequire will infer it!\n\n  - declare it in the above format, but in `bundle.dependencies.varNames` and uRequre will pick it from there!\n\n  - use an `rjs.shim`, and uRequire will pick it from there (@todo: NOT IMPLEMENTED YET!)"));
      }
    }
    l.debug(80, "returning inferred depVars =", depVars);
    return depVars;
  };
  Bundle.prototype.getBundleFile = function (filename) {
    var bf, dstFilename, j, lastResourcesWithClazz, lastSrcMain, len, matchedConverters, ref1, ref2, resConv, resourceClass, sameDstFile;
    if (!(bf = this.files[filename])) {
      lastSrcMain = void 0;
      matchedConverters = [];
      dstFilename = filename;
      ref1 = this.resources;
      for (j = 0, len = ref1.length; j < len; j++) {
        resConv = ref1[j];
        if (umatch(resConv.isMatchSrcFilename ? filename : dstFilename, resConv.filez)) {
          if (_.isFunction(resConv.convFilename)) {
            dstFilename = resConv.convFilename(dstFilename, filename);
          }
          if (resConv.srcMain) {
            lastSrcMain = resConv.srcMain;
          }
          matchedConverters.push(resConv);
        }
      }
      if (lastSrcMain && indexOf.call(this.filenames, lastSrcMain) < 0) {
        throw new UError("srcMain = '" + lastSrcMain + "' doesn't exist in bundle's source filenames.", { quit: true });
      }
      lastResourcesWithClazz = _.filter(matchedConverters, function (conv) {
        return conv.clazz;
      });
      resourceClass = ((ref2 = _.last(lastResourcesWithClazz)) != null ? ref2.clazz : void 0) || BundleFile;
      if (l.deb(80)) {
        l.debug("New *" + resourceClass.name + "*: '" + filename + "'");
      }
      bf = this.files[filename] = new resourceClass({
        bundle: this,
        srcFilename: filename,
        converters: matchedConverters,
        srcMain: lastSrcMain
      });
      if (!bf.srcMain) {
        if (sameDstFile = _.find(this.files, function (_this) {
            return function (f) {
              return f.dstFilename === dstFilename && f !== bf;
            };
          }(this))) {
          sameDstFile.hasErrors = bf.hasErrors = "duplicate";
          this.handleError(new UError("Same dstFilename='" + sameDstFile.dstFilename + "' for new resource '" + bf.srcFilename + "' & '" + sameDstFile.srcFilename + "'."));
        }
      }
    }
    return bf;
  };
  Bundle.prototype.loadOrRefreshResources = function (filenames) {
    if (filenames == null) {
      filenames = this.filenames;
    }
    if (l.deb(30)) {
      l.debug(" \n\n#####################################################################\nloadOrRefreshResources: filenames.length = " + filenames.length + "\n#####################################################################");
    }
    return When.iterate(function (i) {
      return i + 1;
    }, function (i) {
      return !(i < filenames.length);
    }, function (_this) {
      return function (i) {
        var bf, filename, ref1;
        bf = _this.getBundleFile(filename = filenames[i]);
        if (bf.srcMain) {
          if (filename !== bf.srcMain) {
            l.debug(60, "Skipping conversion(s) of '" + bf.srcFilename + "', as part of @srcMain='" + bf.srcMain + "'.");
            if (!_this.build.current["srcMain_inBuild"]) {
              if (ref1 = bf.srcMain, indexOf.call(filenames, ref1) < 0) {
                l.debug(60, "Forcing conversion of @srcMain='" + bf.srcMain + "' triggered by '" + bf.srcFilename + "'.");
                filenames.push(bf.srcMain);
              }
              _this.build.current["srcMain_inBuild"] = true;
              if (_this.files[bf.srcMain]) {
                _this.files[bf.srcMain].reset();
              }
            }
            return;
          }
        }
        if (l.deb(80)) {
          l.debug("Refreshing " + bf.constructor.name + ": '" + filename + "'");
        }
        return bf.refresh().then(function (isChanged) {
          if (isChanged) {
            return _this.build.addChangedBundleFile(filename, bf);
          }
        })["catch"](function (err) {
          if (l.deb(30)) {
            l.debug("Error while refreshing " + bf.constructor.name + ": '" + filename + "'", err);
          }
          _this.build.addChangedBundleFile(filename, bf);
          if (bf.srcExists) {
            if (bf.isDeleteErrored) {
              bf.clean();
            }
            bf.reset();
            bf.hasErrors = true;
            if (err instanceof UError) {
              return _this.handleError(err);
            } else {
              return _this.handleError(new UError("Unknown error while loading/refreshing/processing '" + filename + "'.", { nested: err }));
            }
          } else {
            delete _this.files[filename];
            l.verbose("Missing file " + bf.srcFilepath + " - deleting dstFilename = '" + bf.dstFilename + "'");
            if (bf.hasErrors !== "duplicate") {
              bf.clean();
            }
            return bf.hasErrors = false;
          }
        });
      };
    }(this), 0).then(function (_this) {
      return function () {
        _this.cleanProps(!_.isEmpty(_this.build.changedFiles) ? isCalcPropFiles : void 0, !_.isEmpty(_this.build.changedModules) ? isCalcPropDepsVars : void 0);
        return l.debug("### finished loadOrRefreshResources: " + _.size(_this.build.changedFiles) + " changed files.");
      };
    }(this));
  };
  Bundle.prototype.buildChangedResources = When.lift(function (build1, filenames) {
    var bundleFilenames, diff, file, fn, isPartialBuild, ref1, ref2;
    this.build = build1;
    if (filenames == null) {
      filenames = this.filenames;
    }
    this.build.newBuild();
    if (l.deb(20)) {
      l.debug(" \n\n#####################################################################\nbuildChangedResources: build #" + build.count + "\nbundle.name = " + this.name + ", bundle.main = " + this.main + ", build.target = " + this.build.target + "\n#####################################################################");
    }
    ref1 = this.files;
    for (fn in ref1) {
      file = ref1[fn];
      file.hasChanged = false;
    }
    if (isPartialBuild = filenames !== this.filenames) {
      if (!this.hasFullBuild) {
        l.warn("Forcing a full build (this was a partial build, without a previous full build).");
        ref2 = this.files;
        for (fn in ref2) {
          file = ref2[fn];
          file.reset();
        }
        if (this.build.template.name === "combined") {
          this.build.deleteCombinedTemp();
          l.warn("Partial/watch build with 'combined' template wont DELETE '" + this.build.template._combinedTemp + "' - when you quit 'watch'-ing, delete it your self!");
        }
        filenames = this.filenames;
        isPartialBuild = false;
      } else {
        bundleFilenames = _.filter(filenames, function (_this) {
          return function (f) {
            return umatch(f, _this.filez) && f[0] !== ".";
          };
        }(this));
        if (diff = filenames.length - bundleFilenames.length) {
          l.verbose("Ignored " + diff + " non-`bundle.filez`");
          filenames = bundleFilenames;
        }
      }
    } else {
      if (this.build.count === 1) {
        this.build.doClean();
      }
    }
    this.build.current.isPartial = isPartialBuild;
    if (this.build.template.name === "combined" && !fs.existsSync(this.build.template._combinedTemp) && this.build.count > 1) {
      l.verbose("Resaving _combinedTemp `" + this.build.template._combinedTemp + "` cause build #" + this.build.count + " requested for `" + (this.build.target || "empty build.target") + "` but it was previously deleted.");
      this.saveResources(true);
      this.copyBundleFiles(true);
    }
    if (l.deb(20)) {
      l.deb("Processing " + filenames.length + " files  " + (!isPartialBuild ? "(full build)" : "(partial build)"));
    }
    if (!filenames.length) {
      return l.verbose("No files to process.");
    } else {
      this.reporter = new DependenciesReporter();
      return this.loadOrRefreshResources(filenames).then(function (_this) {
        return function () {
          if (!_.isEmpty(_this.build.changedFiles)) {
            return _this.convertChangedModules().then(function () {
              _this.concatMainModuleBanner();
              _this.saveResources();
              _this.copyBundleFiles();
              return (_this.build.template.name === "combined" ? _this.build.combine()["catch"](function (err) {
                return _this.build.handleError(err);
              }) : When()).then(function () {
                return _this.runAfterSaveConverters().then(function () {
                  return _this.fillDepsInfo();
                });
              });
            })["catch"](function (err) {
              return _this.build.handleError(err);
            })["finally"](function () {
              return _this.build.finishBuild();
            });
          } else {
            l.verbose("No bundle files *really* changed.");
            if (!_.isEmpty(_this.errorFiles)) {
              _this.build.handleError(new Error("There are still " + _.size(_this.errorFiles) + " files with errors in bundle:\n" + l.prettify(_this.errorFiles)));
            }
            return _this.build.finishBuild();
          }
        };
      }(this));
    }
  });
  localPathsCacheFile = ".urequire-local-deps-cache.json";
  Bundle.prototype.fillDepsInfo = When.lift(function () {
    if (this.build.count === 1 && (this.dependencies.paths.bower || this.dependencies.paths.npm)) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nfillDepsInfo: bundle.name = " + this.name + ", bundle.main = " + this.main + ", build.target = " + this.build.target + "\n#####################################################################");
      }
      return this.useLocalCache().then(function (_this) {
        return function (cache) {
          var dirtyCache;
          dirtyCache = {};
          return When.sequence([
            function () {
              if (_this.dependencies.paths.bower) {
                return When(_.isEmpty(cache.bower) ? _this.getBowerPaths().then(function (bowerPaths) {
                  return dirtyCache.bower = bowerPaths;
                }) : cache.bower).then(function (bowerPaths) {
                  l.deb(40, "Blending `bundle.dependencies.paths.bower`");
                  return _this.dependencies.paths.bower = dependenciesBindingsBlender.blend({}, bowerPaths, _this.dependencies.paths.bower);
                });
              } else {
                return When();
              }
            },
            function () {
              if (_this.dependencies.shim) {
                return When(_.isEmpty(cache.shim) ? dirtyCache.shim = _this.getShimDeps() : cache.shim).then(function (bowerShims) {
                  var bowerDep, dv;
                  for (bowerDep in bowerShims) {
                    if (_.isEmpty(bowerShims[bowerDep].exports) && !_.isEmpty(dv = _this.local_depsVars[bowerDep])) {
                      bowerShims[bowerDep].exports = dv[0];
                      if (_.isEmpty(dirtyCache.shim)) {
                        dirtyCache.shim = bowerShims;
                      }
                    }
                  }
                  l.deb(40, "Blending `bundle.dependencies.shim`");
                  return _this.dependencies.shim = shimBlender.blend({}, bowerShims, _this.dependencies.shim);
                });
              }
            },
            function () {
              if (_this.dependencies.paths.npm) {
                return When(_.isEmpty(cache.npm) ? _this.getNpmPaths().then(function (npmPaths) {
                  return dirtyCache.npm = npmPaths;
                }) : cache.npm).then(function (npmPaths) {
                  l.deb(40, "Blending `bundle.dependencies.paths.npm`");
                  return _this.dependencies.paths.npm = dependenciesBindingsBlender.blend(npmPaths, _this.dependencies.paths.npm);
                });
              } else {
                return When();
              }
            },
            function () {
              if (!_.isEmpty(dirtyCache) && _this.dependencies.paths.useCache) {
                l.verbose("Saving dirty paths cache to `" + localPathsCacheFile + "`");
                return fs.writeFileP(localPathsCacheFile, JSON.stringify(_.extend(cache, dirtyCache), null, 2));
              } else {
                return When();
              }
            }
          ]);
        };
      }(this))["catch"](function (_this) {
        return function (err) {
          return _this.build.handleError(new UError("Error while filling `bundle.dependencies.paths`", { nested: err }));
        };
      }(this));
    }
  });
  Bundle.prototype.useLocalCache = function () {
    return fs.existsP(localPathsCacheFile).then(function (_this) {
      return function (isExists) {
        if (isExists) {
          if (_this.dependencies.paths.useCache) {
            l.deb(60, "Loading local paths cache `" + localPathsCacheFile + "`");
            return fs.readFileP(localPathsCacheFile).then(JSON.parse).then(function (cache) {
              if (_.isEmpty(cache)) {
                l.warn("Deleting local paths cache `" + localPathsCacheFile + "` cause its empty.");
                return fs.unlinkP(localPathsCacheFile)["yield"]({});
              } else {
                l.deb(40, "Local paths cache `" + localPathsCacheFile + "` loaded");
                return cache;
              }
            });
          } else {
            l.deb(40, "Deleting local paths cache `" + localPathsCacheFile + "` cause `@dependencies.paths.useCache` is falsey.");
            return fs.unlinkP(localPathsCacheFile)["yield"]({});
          }
        } else {
          return {};
        }
      };
    }(this));
  };
  Bundle.prototype.getNpmPaths = function () {
    var dep, depPaths, deps, error2, j, len, pkg, ref1;
    l.deb(30, "Getting local npm paths (using `package.json` information)");
    if (_.isEmpty(this["package"])) {
      throw new UError("`package.json` is missing / empty, cant fill `bundle.dependencies.paths.npm`");
    }
    depPaths = {};
    ref1 = [
      this["package"].dependencies,
      this["package"].devDependencies
    ];
    for (j = 0, len = ref1.length; j < len; j++) {
      deps = ref1[j];
      for (dep in deps) {
        try {
          pkg = JSON.parse(fs.readFileSync("node_modules/" + dep + "/package.json"));
          depPaths[dep] = upath.join("node_modules", dep, pkg.main);
        } catch (error2) {
          err = error2;
          this.build.handleError(new UError("Error while getting local npm paths (using `package.json` information)", { nested: err }));
        }
      }
    }
    return When(depPaths);
  };
  Bundle.prototype.getBowerPaths = function () {
    var cmd;
    l.deb(30, "Getting local bower paths");
    return When(bower ? (l.verbose("Getting offline bower paths from `require('bower')` module"), When.promise(function (resolve, reject) {
      var bcl;
      bcl = bower.commands.list({
        paths: true,
        offline: true
      });
      bcl.on("end", function (result) {
        return resolve(result);
      });
      return bcl.on("error", function (err) {
        return reject(err);
      });
    })) : (cmd = "bower list --paths --json --offline", l.verbose("Getting offline bower paths from CLI exec `" + cmd + "`"), execP(cmd).spread(JSON.parse))).then(function (bowerPaths) {
      if (_.isEmpty(bowerPaths)) {
        throw new UError("Bower returned empty - run `bower install`");
      }
      return bowerPaths;
    });
  };
  Bundle.prototype.getShimDeps = function () {
    l.verbose("Getting local bower shims using bower paths info");
    return _.mapValues(this.dependencies.paths.bower, function (_this) {
      return function (paths, bowerPackage) {
        var path;
        path = _.isArray(paths) ? paths[0] : paths;
        return { deps: _.keys(JSON.parse(fs.readFileSync(path.slice(0, +(path.indexOf(bowerPackage) + bowerPackage.length) + 1 || 9000000000) + ".bower.json", "utf8")).dependencies) };
      };
    }(this));
  };
  Bundle.prototype.runAfterSaveConverters = function () {
    var changedFileResources, file, fn;
    changedFileResources = function () {
      var ref1, results;
      ref1 = this.fileResources;
      results = [];
      for (fn in ref1) {
        file = ref1[fn];
        if (file.hasChanged && !file.hasErrors) {
          results.push(file);
        }
      }
      return results;
    }.call(this);
    if (changedFileResources.length) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nRunning `runAt: 'afterSave'` ResourceConverters for " + changedFileResources.length + " changed `FileResource`s.\n#####################################################################");
      }
    }
    return When.each(changedFileResources, function (_this) {
      return function (f) {
        f.hasChanged = false;
        return f.runResourceConverters(function (rc) {
          return rc.runAt === "afterSave";
        }).then(function () {
          if (f.hasChanged) {
            f.save();
          }
          return f.hasChanged = true;
        });
      };
    }(this));
  };
  Bundle.prototype.convertChangedModules = function () {
    var changedModules, fn, mod;
    changedModules = function () {
      var ref1, results;
      ref1 = this.modules;
      results = [];
      for (fn in ref1) {
        mod = ref1[fn];
        if (mod.hasChanged && !mod.hasErrors) {
          results.push(mod);
        }
      }
      return results;
    }.call(this);
    if (changedModules.length) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nConverting " + changedModules.length + " changed modules with template '" + this.build.template.name + "'\n#####################################################################");
      }
    }
    return When.each(changedModules, function (_this) {
      return function (mod) {
        return mod.convert(_this.build);
      };
    }(this));
  };
  Bundle.prototype.concatMainModuleBanner = function () {
    if (this.build.template.banner && this.build.template.name !== "combined") {
      if (this.mainModule) {
        if (this.mainModule.hasChanged && !this.mainModule.hasErrors) {
          l.debug(40, "Concating `bundle.template.banner` to `@bundle.main` module dstFilename = `" + this.mainModule.dstFilename + "`");
          if (!_.isEmpty(this.mainModule.converted) && _.isString(this.mainModule.converted)) {
            this.mainModule.converted = this.build.template.banner + "\n" + this.mainModule.converted;
          }
        }
      } else {
        l.warn("Can't concat `build.template.banner` - no @mainModule - tried `bundle.main`, `bundle.name`, 'index', 'main'.");
      }
    }
    return null;
  };
  Bundle.prototype.saveResources = function (all) {
    var error2, fn, j, len, res, resourcesToSave;
    resourcesToSave = function () {
      var ref1, results;
      ref1 = this.fileResources;
      results = [];
      for (fn in ref1) {
        res = ref1[fn];
        if ((res.hasChanged || all) && !res.hasErrors) {
          results.push(res);
        }
      }
      return results;
    }.call(this);
    if (resourcesToSave) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nSaving " + _.size(resourcesToSave) + " resource files " + (all ? "(all)" : "(changed)") + " that have a `converted` String and no errors.\n#####################################################################");
      }
      for (j = 0, len = resourcesToSave.length; j < len; j++) {
        res = resourcesToSave[j];
        if (!_.isEmpty(res.converted) && _.isString(res.converted)) {
          try {
            if (_.isFunction(this.build.out)) {
              this.build.out(res.dstFilename, res.converted, res);
            } else {
              res.save();
            }
          } catch (error2) {
            err = error2;
            res.hasErrors = true;
            this.handleError(new UError("Error while " + (_.isFunction(this.build.out) ? "`build.out()`-ing" : "`save()`-ing") + " resource '" + res.dstFilename + "'.", { nested: err }));
          }
        } else {
          l.verbose("Not saving non-String: '" + res.srcFilename + "' as '" + res.dstFilename + "'.");
        }
      }
    }
    return null;
  };
  Bundle.prototype.copyBundleFiles = function (all) {
    var bundleFile, bundleFilesToCopy, copiedCount, error2, fn, skippedCount;
    bundleFilesToCopy = _.pick(this.files, function (_this) {
      return function (f, filename) {
        return !(f instanceof FileResource) && umatch(filename, _this.copy) && (f.hasChanged || all);
      };
    }(this));
    if (!_.isEmpty(bundleFilesToCopy)) {
      if (l.deb(30)) {
        l.debug(" \n\n#####################################################################\nCopying " + _.size(bundleFilesToCopy) + " BundleFiles files " + (all ? "(all)" : "(changed)") + " that match `bundle.copy`.\"\n#####################################################################");
      }
      copiedCount = skippedCount = 0;
      for (fn in bundleFilesToCopy) {
        bundleFile = bundleFilesToCopy[fn];
        try {
          if (bundleFile.copy()) {
            copiedCount++;
          } else {
            skippedCount++;
          }
        } catch (error2) {
          err = error2;
          bundleFile.hasErrors = true;
          this.handleError(err);
        }
      }
    }
    return this.build._copied = [
      copiedCount,
      skippedCount
    ];
  };
  Bundle.prototype.ensureMain = function (force) {
    var combErr, error;
    if (force == null) {
      force = true;
    }
    if (this.mainModule) {
      if (!this.main) {
        this.main = this.mainModule.path;
        l.warn("`bundle.main` is defaulting to " + (this.main === this.name ? "`bundle.name` = " : "") + "'" + this.main + "', as uRequire found " + (_.size(this.modules) === 1 ? "only one" : "a valid main") + " module `" + this.mainModule.srcFilename + "` in `bundle.path` filtered with `bundle.filez`.");
      }
      return this.mainModule;
    } else {
      combErr = "`bundle.main` should be your *entry-point module*, kicking off the bundle:\n" + (this.build.template.name === "combined" ? "   * It is the return value of the `combined` template bundle factory, i.e. the value of the whole bundle. " + "Without it, ALL modules will be loaded (usefull if this bundle is just `specs`), but the value of the bundle as a module will be `undefined` on AMD.\n" : "") + "   * various `ResourceConverter`s & `afterBuild`ers might need it.";
      error = !this.main ? "Missing `bundle.main` from config of bundle.name=`" + this.name + "`, build.target=`" + this.build.target + "`.\n" + combErr + "\nTried to infer it from `bundle.name` = '" + this.name + "', or as ['index', 'main'], but no suitable module was found in bundle." : "Module `bundle.main` = '" + this.main + "' not found in bundle `" + this.name + "`, build.target=`" + this.build.target + "`.\n" + combErr + "\nNOT trying to infer from `bundle.name` = '" + this.name + "', nor as ['index', 'main'] - `bundle.main` is always respected.";
      if (force) {
        return this.handleError(new UError(error));
      } else {
        l.warn(error);
        return null;
      }
    }
  };
  Object.defineProperties(Bundle.prototype, {
    "package": {
      get: function () {
        var error2, pkg;
        try {
          pkg = JSON.parse(fs.readFileSync("package.json", { encoding: "utf8" }));
        } catch (error2) {
        }
        return pkg || {};
      }
    },
    bower: {
      get: function () {
        var bow, error2;
        try {
          bow = JSON.parse(fs.readFileSync("bower.json", { encoding: "utf8" }));
        } catch (error2) {
        }
        return bow || {};
      }
    },
    mergedPreDefineIIFECode: {
      get: function () {
        var cm, m, mod, ref1;
        if (l.deb(80)) {
          l.debug("Merging pre-Define IIFE code from all " + _.size(this.modules) + " @modules");
        }
        cm = new CodeMerger();
        ref1 = this.modules;
        for (m in ref1) {
          mod = ref1[m];
          cm.add(mod.AST_preDefineIIFENodes);
        }
        return toCode(cm.AST, { format: { indent: { base: 1 } } });
      }
    },
    mergedCode: {
      get: function () {
        var cm, m, mod, ref1;
        if (l.deb(80)) {
          l.debug("Merging mergedCode code from all " + _.size(this.modules) + " @modules");
        }
        cm = new CodeMerger();
        ref1 = this.modules;
        for (m in ref1) {
          mod = ref1[m];
          cm.add(mod.mergedCode);
        }
        return toCode(cm.AST, { format: { indent: { base: 1 } } });
      }
    }
  });
  Bundle.prototype.handleError = function (error) {
    return this.build.handleError(error);
  };
  return Bundle;
}(BundleBase);
module.exports = Bundle;
_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});

;