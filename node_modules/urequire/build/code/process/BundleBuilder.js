// Generated by uRequire v0.7.0-beta.23 target: 'lib' template: 'nodejs'

var _ = require('lodash'),
    _B = require('uberscore'),
    UError = require('../utils/UError');

var l = new _B.Logger('uRequire/process/BundleBuilder');

var BundleBuilder, VERSION, When, fs, upath, urequire, bind = function (fn, me) {
    return function () {
      return fn.apply(me, arguments);
    };
  }, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  };
fs = require("fs");
upath = require("upath");
When = require("when");
VERSION = (urequire = require("../urequire")).VERSION;
module.exports = BundleBuilder = function () {
  var verboseRef;
  function BundleBuilder(configs, deriveLoader) {
    this.watch = bind(this.watch, this);
    var err, error, uerr;
    this.configs = configs = _B.arrayize(configs);
    this.l = l;
    this.urequire = urequire;
    this.Build = require("./Build");
    this.Bundle = require("./Bundle");
    this.blendConfigs = require("../config/blendConfigs");
    this.config = this.blendConfigs(_.flatten(configs), deriveLoader, true);
    _.defaults(this.config.bundle, { filez: ["**/*"] });
    this.setDebugVerbose();
    if (l.deb(10)) {
      l.debug("Final config (with master defaults):\n", this.config);
    }
    this.checkAndFixPaths();
    this.checkTemplate();
    try {
      this.bundle = new this.Bundle(this.config.bundle);
      this.build = new this.Build(this.config.build, this.bundle);
      this.urequire.addBBCreated(this);
    } catch (error) {
      err = error;
      l.er(uerr = "Generic error while initializing @bundle or @build \n", err);
      throw new UError(uerr, { nested: err });
    }
  }
  BundleBuilder.prototype.inspect = function () {
    return "BundleBuilder:\n" + l.prettify(this.bundle) + "\n" + l.prettify(this.build);
  };
  verboseRef = _B.Logger.prototype.verbose;
  BundleBuilder.prototype.setDebugVerbose = function () {
    var ref;
    _B.Logger.addDebugPathLevel("uRequire", this.config.build.debugLevel);
    if (this.config.build.verbose) {
      return _B.Logger.prototype.verbose = verboseRef;
    } else {
      if (this.config.build.debugLevel >= 50) {
        _B.Logger.prototype.verbose = verboseRef;
        if (((ref = this.build) != null ? ref.count : void 0) === void 0) {
          return l.warn("Enabling verbose, because debugLevel >= 50");
        }
      } else {
        return _B.Logger.prototype.verbose = function () {
        };
      }
    }
  };
  BundleBuilder.prototype.buildBundle = When.lift(function (filenames) {
    var bcr, err;
    if (this.build && this.bundle) {
      if (urequire.targets) {
        return When.reject(new Error("urequire >= v0.7.0 requires grunt-urequire >= 0.7.0"));
      }
      this.setDebugVerbose();
      urequire.addBBExecuted(this);
      bcr = this.bundle.buildChangedResources(this.build, filenames)["catch"](function (_this) {
        return function (err) {
          return _this.build.handleError(err);
        };
      }(this))["finally"](function (_this) {
        return function () {
          return _this.runAfterBuildTasks();
        };
      }(this));
      return bcr.then(function (_this) {
        return function () {
          if (!_this.build.hasErrors) {
            return _this;
          } else {
            return When.reject(_this.build.errors);
          }
        };
      }(this));
    } else {
      l.er(err = "buildBundle(): I have !@build or !@bundle - can't build anything!");
      throw new UError(err);
    }
  });
  BundleBuilder.prototype.runAfterBuildTasks = function () {
    return When.each(_B.arrayize(this.build.afterBuild), function (_this) {
      return function (task, idx) {
        var errors;
        l.deb(30, "Running `build.afterBuild()` task #" + idx + (l.deb(70) ? task.toString().slice(0, 101) + "...more..." : ""));
        errors = _.isEmpty(_this.build.errors) ? null : _this.build.errors;
        return When().then(function () {
          var callbackPromise, deferred, fnPromise;
          if (task.length === 3) {
            callbackPromise = (deferred = When.defer()).promise;
            fnPromise = task(errors, _this, When.node.createCallback(deferred.resolver));
            return When.race(_.filter([
              callbackPromise,
              fnPromise
            ], function (it) {
              return When.isPromiseLike(it);
            }));
          } else {
            if (task.length === 2) {
              return task(errors, _this);
            } else {
              if (task.length === 1) {
                return task(errors === null ? true : errors);
              } else {
                throw new UError("Unknown number of arguments for `afterBuild()`: \n " + task.toString().slice(0, 101));
              }
            }
          }
        })["catch"](function (er) {
          er = new UError("Error running `build.afterBuild()` task #" + idx, { nested: er });
          _this.build.printError(er);
          return _this.build.errors.push(er);
        });
      };
    }(this));
  };
  BundleBuilder.prototype.watch = function (options) {
    var bundleBuilder, chokidar, path, runBuildBundleDebounced, watchFiles;
    if (options == null) {
      options = this.build.watch;
    }
    if (_.isNumber(options)) {
      options = this.build.watch;
    }
    if (!_.isNumber(options.debounceDelay)) {
      options.debounceDelay = 1000;
    }
    l.ok("Watching started... (with `_.debounce delay` " + options.debounceDelay + "ms)");
    bundleBuilder = this;
    this.build.afterBuild.push(function (_this) {
      return function (errors, res) {
        var msg;
        msg = "Watched build #" + _this.build.count + " took " + (new Date() - _this.build.startDate) / 1000 + "secs - ";
        if (!err) {
          return l.ok(msg + "Watching again...");
        } else {
          return l.err(msg + ("it has " + _.size(errors) + " - Watching again..."));
        }
      };
    }(this));
    watchFiles = [];
    chokidar = require("chokidar");
    path = require("path");
    fs = require("fs");
    chokidar.watch(bundleBuilder.bundle.path + "/**/*", { alwaysStat: true }).on("all", function (event, filepath, filepathStat) {
      filepath = path.relative(process.cwd(), filepath);
      if (filepathStat != null ? filepathStat.isDirectory() : void 0) {
        return l.warn("Adding '" + filepath + "' as new watch directory is NOT SUPPORTED.");
      } else {
        l.verbose("Watched file '" + filepath + "' has '" + event + "'. [33m (waiting watch events for " + options.debounceDelay + "ms)");
        watchFiles.push(path.relative(bundleBuilder.bundle.path, filepath));
        return runBuildBundleDebounced();
      }
    });
    return runBuildBundleDebounced = _.debounce(function () {
      if (!_.isEmpty(watchFiles = _.unique(watchFiles))) {
        l.ok("Starting build #" + (bundleBuilder.build.count + 1) + " for " + l.prettify(watchFiles));
        return bundleBuilder.buildBundle(watchFiles)["finally"](function () {
          return watchFiles = [];
        });
      } else {
        return l.warn("Ignoring EMPTY watchFiles = ", watchFiles);
      }
    }, options.debounceDelay);
  };
  BundleBuilder.prototype.checkTemplate = function () {
    var ref;
    if (ref = this.config.build.template.name, indexOf.call(this.Build.templates, ref) < 0) {
      throw new UError("Quitting build, invalid template '" + this.config.build.template.name + "' specified.\nUse -h for help");
    }
  };
  BundleBuilder.prototype.checkAndFixPaths = function () {
    var cfgFile, dirName, ref, ref1, ref2;
    if (((ref = this.config.bundle) != null ? ref.path : void 0) == null) {
      if (cfgFile = (ref1 = this.configs[0]) != null ? (ref2 = ref1.derive) != null ? ref2[0] : void 0 : void 0) {
        if (dirName = upath.dirname(cfgFile)) {
          l.warn("Assuming path = '" + dirName + "' from 1st configFile: '" + cfgFile + "'");
          this.config.bundle.path = dirName;
        } else {
          throw new UError("Quitting build, cant assume `bundle.path` from 1st configFile: '" + cfgFile + "'");
        }
      } else {
        throw new UError("Quitting build, no `path` / `bundle.path` specified. Use -h for help.");
      }
    }
    if (!fs.existsSync(this.config.bundle.path)) {
      throw new UError("Quitting build, `bundle.path` '" + this.config.bundle.path + "' not fs.exists. \nprocess.cwd()= " + process.cwd());
    } else {
      if (this.config.build.forceOverwriteSources) {
        this.config.build.dstPath = this.config.bundle.path;
        return l.verbose("forceOverwriteSources: `build.dstPath` set to `bundle.path` '" + this.config.build.dstPath + "'");
      } else {
        if (!(this.config.build.dstPath || this.config.build.template.name === "combined" && this.config.build.template.combinedFile)) {
          throw new UError("Quitting build cause:\n  * no `--dstPath` / `build.dstPath` specified.\n  " + (this.config.build.template.name === "combined" ? "* no `build.template.combinedFile` specified" : "") + "\nUse -f *with caution* to overwrite sources (no need to specify & ignored --dstPath).");
        }
        if (this.config.build.dstPath && upath.normalize(this.config.build.dstPath) === upath.normalize(this.config.bundle.path)) {
          throw new UError("Quitting build, dstPath === path.\nUse -f *with caution* to overwrite sources (no need to specify & ignored `--dstPath` / `build.dstPath`).");
        }
      }
    }
  };
  return BundleBuilder;
}();

;