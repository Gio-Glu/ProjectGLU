// Generated by uRequire v0.7.0-beta.23 target: 'lib' template: 'nodejs'

var _ = require('lodash'),
    _B = require('uberscore'),
    UError = require('../utils/UError');

var l = new _B.Logger('uRequire/process/Build');

var AlmondOptimizationTemplate, Build, BundleFile, DependenciesReporter, FileResource, MasterDefaultsConfig, Module, When, dependenciesBindingsBlender, fs, globExpand, isTrueOrFileMatch, moment, ref, rimraf, shimBlender, umatch, upath, url, extend = function (child, parent) {
    for (var key in parent) {
      if (hasProp.call(parent, key))
        child[key] = parent[key];
    }
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    return child;
  }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item)
        return i;
    }
    return -1;
  };
fs = require("fs");
rimraf = require("rimraf");
globExpand = require("glob-expand");
moment = require("moment");
url = require("url");
upath = require("upath");
umatch = require("umatch");
When = require("../promises/whenFull");
isTrueOrFileMatch = require("../config/isTrueOrFileMatch");
BundleFile = require("../fileResources/BundleFile");
AlmondOptimizationTemplate = require("../templates/AlmondOptimizationTemplate");
DependenciesReporter = require("../utils/DependenciesReporter");
MasterDefaultsConfig = require("../config/MasterDefaultsConfig");
ref = require("../config/blendConfigs"), shimBlender = ref.shimBlender, dependenciesBindingsBlender = ref.dependenciesBindingsBlender;
FileResource = null;
Module = null;
module.exports = Build = function (superClass) {
  var sortDepsByShim;
  extend(Build, superClass);
  function Build(buildCfg, bundle) {
    this.bundle = bundle;
    Build.__super__.constructor.apply(this, arguments);
    _.extend(this, buildCfg);
    Module = require("../fileResources/Module");
    FileResource = require("../fileResources/FileResource");
    this.count = 0;
    this.setupCombinedFile();
    this.calcTemplateBanner();
  }
  Build.prototype.setupCombinedFile = function () {
    if (this.template.name === "combined") {
      if (!this.template.combinedFile) {
        this.template.combinedFile = this.dstPath;
        this.dstPath = upath.dirname(this.dstPath);
        l.verbose("`build.template` is 'combined' and `build.template.combinedFile` is undefined:\nSetting `build.template.combinedFile` = '" + this.template.combinedFile + "' from `build.dstPath`\nand `build.dstPath` = '" + this.dstPath + "' (keeping only path.dirname).");
      }
      this.template.combinedFile = upath.changeExt(this.template.combinedFile, ".js");
      this.template._combinedTemp = this.template.combinedFile + "___temp";
      if (!this.dstPath) {
        this.dstPath = upath.dirname(this.template.combinedFile);
        l.verbose("`build.template` is 'combined' and `build.dstPath` is undefined:\n Setting `build.dstPath` = '" + this.dstPath + "' from `build.template.combinedFile` = '" + this.template.combinedFile + "'");
      }
      if (this.out) {
        l.warn("`build.out` is deleted due to `combined` template being used - r.js doesn't work in memory yet.");
        return delete this.out;
      }
    }
  };
  Build.prototype.calcTemplateBanner = function () {
    var pkg, ref1, ref2, ref3, ref4, tb;
    if (tb = this.template.banner) {
      if (_.isString(tb)) {
        return;
      } else {
        if (_B.isHash(tb)) {
          pkg = tb;
        }
      }
      if (_.isEmpty(pkg) && _.isEmpty(pkg = this.bundle["package"])) {
        throw new UError("`bundle.package` is missing or empty (`package.json` not found or has errors),\n but `build.template.banner` = " + tb + " requires it!\n Either set `build.template.banner` to false or a package-like `{}`");
      }
      if (tb === true || tb === pkg) {
        return this.template.banner = "/**\n* " + pkg.name + " " + ((pkg != null ? pkg.homepage : void 0) && (pkg != null ? pkg.homepage : void 0) !== (pkg != null ? (ref1 = pkg.repository) != null ? ref1.url : void 0 : void 0) ? pkg != null ? pkg.homepage : void 0 : "") + "\n*\n* " + (pkg != null ? pkg.description : void 0) + "\n* Version " + (pkg != null ? pkg.version : void 0) + " - Compiled on " + moment().format("YYYY-MM-DD HH:mm:ss") + "\n* Repository " + (pkg != null ? (ref2 = pkg.repository) != null ? ref2.url : void 0 : void 0) + "\n* Copyright(c) " + moment().format("YYYY") + " " + (_.isString(pkg.author) ? pkg.author : _B.isHash(pkg.author) ? pkg.author.name + " <" + pkg.author.email + ">" + (pkg.author.url ? "(" + pkg.author.url(+")") : "") : "") + "\n* License " + (pkg.license || (pkg.licenses ? ((ref3 = pkg.licenses[0]) != null ? ref3.type : void 0) + " " + ((ref4 = pkg.licenses[0]) != null ? ref4.url : void 0) : "")) + "\n*/\n";
      } else {
        if (_.isFunction(tb)) {
          return this.template.banner = tb(pkg, this.bundle.bower, this.bundle, this);
        } else {
          throw new Error("Unknown `build.template.banner` value type `" + _B.type(tb) + "`.");
        }
      }
    }
  };
  Build.templates = [
    "UMD",
    "UMDplain",
    "AMD",
    "nodejs",
    "combined"
  ];
  Build.prototype.inspect = function () {
    return "Build:" + l.prettify({
      dstPath: this.dstPath,
      template: this.template,
      startDate: this.startDate,
      count: this.count
    });
  };
  Object.defineProperties(Build.prototype, {
    dstMainFilename: {
      get: function () {
        if (this.template.name === "combined") {
          return upath.basename(this.template.combinedFile);
        } else {
          return this.bundle.ensureMain().dstFilename;
        }
      }
    },
    dstMainFilepath: {
      get: function () {
        return upath.join(this.dstPath, this.dstMainFilename);
      }
    },
    dstMainRealpath: {
      get: function () {
        return upath.join(process.cwd(), this.dstMainFilepath);
      }
    },
    dstRealpath: {
      get: function () {
        return upath.join(process.cwd(), this.dstPath);
      }
    },
    hasErrors: {
      get: function () {
        return !_.isEmpty(this.bundle.errorFiles) || !_.isEmpty(this.errors);
      }
    }
  });
  Build.calcProperties = {
    changedModules: function () {
      return _.pick(this._changed, function (f) {
        return f instanceof Module;
      });
    },
    changedResources: function () {
      return _.pick(this._changed, function (f) {
        return f instanceof FileResource;
      });
    },
    changedErrorFiles: function () {
      return _.pick(this._changed, function (f) {
        return f.hasErrors;
      });
    },
    changedFiles: function () {
      return this._changed;
    },
    hasChanged: function () {
      return !_.isEmpty(this._changed);
    },
    dstPathToRoot: function () {
      return upath.relative(upath.join(process.cwd(), this.dstPath), process.cwd());
    }
  };
  Build.prototype.calcRequireJsConfig = function (toPath, blendWithCfg, strictDeps, ignoreDeps) {
    var dep, depPaths, len, localNonNodeDepFilter, m, neededDeps, nonEmptyShims, pathToRoot, ref1, ref2, rjsCfg;
    if (toPath == null) {
      toPath = this.dstPath;
    }
    if (ignoreDeps == null) {
      ignoreDeps = [];
    }
    depPaths = dependenciesBindingsBlender.blend.apply(null, [
      this.bundle.dependencies.paths.override,
      blendWithCfg != null ? blendWithCfg.paths : void 0,
      this.bundle.dependencies.locals,
      this.bundle.dependencies.paths.bower,
      (ref1 = this.rjs) != null ? ref1.paths : void 0,
      this.bundle.dependencies.paths.npm
    ].reverse());
    if (strictDeps) {
      if (strictDeps === true) {
        strictDeps = [];
      }
      localNonNodeDepFilter = function (d) {
        return d.isLocal && !d.isNode;
      };
      neededDeps = _.keys(dependenciesBindingsBlender.blend({}, this.bundle.getImports_depsVars(localNonNodeDepFilter), this.bundle.getModules_depsVars(localNonNodeDepFilter), blendWithCfg != null ? blendWithCfg.paths : void 0)).concat(strictDeps).map(function (dep) {
        return dep.split("/")[0];
      });
      for (m = 0, len = neededDeps.length; m < len; m++) {
        dep = neededDeps[m];
        if (_.isEmpty(depPaths[dep]) && indexOf.call(ignoreDeps, dep) < 0) {
          throw new Error("\n\n`calcRequireJsConfig` error for build.target='" + this.target + "', bundle.name='" + this.bundle.name + "':\n Path for local non-node dependency `" + dep + "` is undefined in `dependencies.paths.xxx`.\n\n * If you want to include this path you can either:\n     a) `$ bower install " + dep + "` and set `dependencies: paths: bower: true` in your config.\n     b) `$ npm install " + dep + "` and set `dependencies: paths: npm: true` in your config (but be careful cause some npm `node_modules` wont work on the browser/AMD).\n     c) manually set `dependencies: paths: override` to the `" + dep + ".js` lib eg\n      `dependencies: paths: override: { '" + dep + "': 'node_modules/" + dep + "/path/to/" + dep + ".js' }` (relative from project root, not `path`/`dstPath`)\n   Then delete `urequire-local-deps-cache.json` and re-run uRequire.\n\n * If you want to ignore this dep add it to `ignoreDeps` (4rth param) of `calcRequireJsConfig()`\n\n All discovered paths (before duplicates removal) are:\n\n" + l.prettify(depPaths));
        }
      }
    }
    depPaths = _.pick(depPaths, function (p, dep) {
      return (!neededDeps || indexOf.call(neededDeps, dep) >= 0) && indexOf.call(ignoreDeps, dep) < 0;
    });
    pathToRoot = upath.relative(upath.join(process.cwd(), toPath), process.cwd());
    depPaths = _.mapValues(depPaths, function (paths) {
      return _.uniq(_.map(paths, function (path) {
        if (!url.parse(path).protocol) {
          path = upath.join(pathToRoot, path);
        }
        return upath.removeExt(path, ".js");
      }));
    });
    if (!this.bundle.dependencies.shim) {
      l.warn("calcRequireJsConfig: `@bundle.dependencies.shim` is not enabled - shim info will be incomplete.");
    }
    nonEmptyShims = _.pick(shimBlender.blend.apply(null, [
      {},
      blendWithCfg != null ? blendWithCfg.shim : void 0,
      (ref2 = this.rjs) != null ? ref2.shim : void 0,
      this.bundle.dependencies.shim
    ].reverse()), function (sh) {
      return !_.isEmpty(sh.deps) || !_.isEmpty(sh.exports);
    });
    rjsCfg = {
      baseUrl: toPath === this.dstPath ? "." : upath.relative(upath.join(process.cwd(), this.dstPath), upath.join(process.cwd(), toPath)) || ".",
      paths: depPaths,
      shim: nonEmptyShims
    };
    Object.defineProperties(rjsCfg, {
      shimSortedDeps: {
        get: function () {
          return sortDepsByShim(_.keys(depPaths), nonEmptyShims);
        }
      }
    });
    return rjsCfg;
  };
  sortDepsByShim = function (arr, shim) {
    var dep_i, dep_j, i, j, len, len1, m, n, ref1, ref2, swap;
    swap = function (a, b) {
      var temp;
      temp = arr[a];
      arr[a] = arr[b];
      return arr[b] = temp;
    };
    for (i = m = 0, len = arr.length; m < len; i = ++m) {
      dep_i = arr[i];
      for (j = n = 0, len1 = arr.length; n < len1; j = ++n) {
        dep_j = arr[j];
        if (ref1 = arr[i], indexOf.call((shim != null ? (ref2 = shim[arr[j]]) != null ? ref2.deps : void 0 : void 0) || [], ref1) >= 0) {
          swap(j, i);
        }
      }
    }
    return arr;
  };
  Build.prototype.newBuild = function () {
    this.startDate = new Date();
    this.errors = [];
    this.count++;
    this.current = {};
    this._changed = {};
    return this.cleanProps();
  };
  Build.prototype.finishBuild = function () {
    if (!this.hasErrors && !this.current.isPartial) {
      this.bundle.hasFullBuild = this.count;
    }
    this.cleanUp();
    return this.report();
  };
  Build.prototype.addChangedBundleFile = function (filename, bundleFile) {
    return this._changed[filename] = bundleFile;
  };
  Build.prototype.doClean = function () {
    var delFiles, df, err, error1, error2, len, m, results;
    if (this.clean) {
      this.deleteCombinedTemp();
      if (_B.isTrue(this.clean)) {
        if (_B.isTrue(function (_this) {
            return function () {
              var er, error1;
              try {
                return fs.existsSync(_this.dstPath);
              } catch (error1) {
                er = error1;
              }
            };
          }(this)())) {
          if (this.template.name === "combined") {
            return this.deleteCombinedFile();
          } else {
            l.verbose("clean: deleting whole build.dstPath '" + this.dstPath + "'.");
            try {
              return rimraf.sync(this.dstPath);
            } catch (error1) {
              err = error1;
              return l.warn("Can't delete build.dstPath dir '" + this.dstPath + "'.", err);
            }
          }
        } else {
          return l.verbose("clean: build.dstPath '" + this.dstPath + "' does not exist.");
        }
      } else {
        delFiles = _.filter(globExpand({
          cwd: this.dstPath,
          filter: "isFile"
        }, "**/*"), function (_this) {
          return function (f) {
            return umatch(f, _this.clean);
          };
        }(this));
        if (!_.isEmpty(delFiles)) {
          l.verbose("clean: deleting " + delFiles.length + " files matched with filespec", this.clean);
          results = [];
          for (m = 0, len = delFiles.length; m < len; m++) {
            df = delFiles[m];
            l.verbose("clean: deleting file '" + (df = upath.join(this.dstPath, df)) + "'.");
            try {
              results.push(fs.unlinkSync(df));
            } catch (error2) {
              err = error2;
              results.push(l.warn("Can't delete file '" + df + "'.", err));
            }
          }
          return results;
        } else {
          return l.verbose("clean: no files matched filespec", this.clean);
        }
      }
    }
  };
  Build.prototype.deleteCombinedTemp = function () {
    var err, error1;
    if (this.template.name === "combined") {
      if (_B.isTrue(function (_this) {
          return function () {
            var er, error1;
            try {
              return fs.existsSync(_this.template._combinedTemp);
            } catch (error1) {
              er = error1;
            }
          };
        }(this)())) {
        l.debug(30, "Deleting temporary combined directory '" + this.template._combinedTemp + "'.");
        try {
          return rimraf.sync(this.template._combinedTemp);
        } catch (error1) {
          err = error1;
          return l.warn("Can't delete temp dir '" + this.template._combinedTemp + "':", err);
        }
      }
    }
  };
  Build.prototype.deleteCombinedFile = function () {
    var err, error1;
    if (this.template.name === "combined") {
      if (_B.isTrue(function (_this) {
          return function () {
            var er, error1;
            try {
              return fs.existsSync(_this.template.combinedFile);
            } catch (error1) {
              er = error1;
            }
          };
        }(this)())) {
        l.verbose("Deleting combinedFile '" + this.template.combinedFile + "'.");
        try {
          return fs.unlinkSync(this.template.combinedFile);
        } catch (error1) {
          err = error1;
          return l.warn("Can't delete combinedFile '" + this.template.combinedFile + "':", err);
        }
      }
    }
  };
  Build.prototype.cleanUp = function () {
    var skipDeleteLevel;
    if (this.template.name === "combined") {
      if (!(l.deb(skipDeleteLevel = 50) || this.watch.enabled)) {
        return this.deleteCombinedTemp();
      } else {
        return l.debug(10, "NOT Deleting temporary directory '" + this.template._combinedTemp + "', " + ("due to build.watch || debugLevel >= " + skipDeleteLevel + "."));
      }
    }
  };
  Build.prototype.grabAlmondJs = function () {
    var almondJsDst, almondJsPath, err, error1;
    if (!fs.existsSync(almondJsDst = upath.join(this.template._combinedTemp, "almond.js"))) {
      try {
        almondJsPath = require.resolve("almond");
        BundleFile.copy(almondJsPath, almondJsDst);
      } catch (error1) {
        err = error1;
        this.handleError(new UError("uRequire: error copying almond.js from uRequire's installation `node_modules`.\nTried: '" + almondJsPath + "'", { nested: err }));
      }
      return this.almondVersion || (this.almondVersion = JSON.parse(fs.readFileSync(upath.dirname(almondJsPath) + "/package.json")).version);
    }
  };
  Build.prototype.copyWebMapDeps = function () {
    var depName, len, m, webRootDeps;
    webRootDeps = _.keys(this.bundle.getModules_depsVars(function (dep) {
      return dep.isWebRootMap;
    }));
    if (!_.isEmpty(webRootDeps)) {
      l.verbose("Copying webRoot deps :\n", webRootDeps);
      for (m = 0, len = webRootDeps.length; m < len; m++) {
        depName = webRootDeps[m];
        l.er("NOT IMPLEMENTED: copyWebMapDeps " + this.webRoot + depName + ", " + this.template._combinedTemp + depName);
      }
    }
    return null;
  };
  Build.prototype.requirejs = require("requirejs");
  Build.prototype.combine = function () {
    return When.promise(function (_this) {
      return function (resolve, reject) {
        var combinedTemplate, depfilename, errFiles, genCode, k, mod, ref1, rjsConfig, rjsStartDate;
        if (_.isEmpty(_this.changedFiles)) {
          l.verbose("Not executing *'combined' template optimizing with r.js*: no @files changed in build #" + _this.count + ".");
          return resolve();
        } else {
          if (errFiles = _.size(_this.bundle.errorFiles)) {
            if (isTrueOrFileMatch(_this.deleteErrored, _this.template.combinedFile)) {
              _this.deleteCombinedFile();
              if (_this["continue"]) {
                l.er("Executing *'combined' optimizing with r.js* although there are " + errFiles + " error files in the bundle, due to `build.continue`.");
              } else {
                l.er("Not executing *'combined' optimizing with r.js*: there are " + errFiles + " error files the bundle.");
                return resolve();
              }
            }
          }
        }
        if (l.deb(30)) {
          l.debug(" \n\n#####################################################################\n'combined' template: optimizing with r.js & almond\n#####################################################################");
        }
        if (!_this.bundle.main && _this.count === 1) {
          l.warn("`combined` template warning: `bundle.main`, your *entry-point module* is missing from `bundle` config.");
          _this.bundle.ensureMain(false);
        }
        combinedTemplate = new AlmondOptimizationTemplate(_this.bundle);
        ref1 = combinedTemplate.dependencyFiles;
        for (depfilename in ref1) {
          genCode = ref1[depfilename];
          FileResource.save(upath.join(_this.template._combinedTemp, depfilename + ".js"), genCode);
        }
        _this.grabAlmondJs();
        _this.copyWebMapDeps();
        rjsConfig = {
          paths: combinedTemplate.paths,
          wrap: combinedTemplate.wrap,
          baseUrl: _this.template._combinedTemp,
          include: _this.bundle.main ? [_this.bundle.ensureMain().path] : function () {
            var ref2, results;
            ref2 = this.bundle.modules;
            results = [];
            for (k in ref2) {
              mod = ref2[k];
              results.push(upath.trimExt(mod.dstFilename));
            }
            return results;
          }.call(_this),
          deps: _.union(_.keys(_this.bundle.local_node_depsVars), _.keys(_this.bundle.imports_bundle_depsVars), _.keys(_this.bundle.modules_node_depsVars)),
          useStrict: _this.useStrict || _.isUndefined(_this.useStrict) ? true : false,
          name: "almond",
          out: function (text) {
            text = (_this.template.banner ? _this.template.banner + "\n" : "") + combinedTemplate.uRequireBanner + ("// Combined template optimized with RequireJS/r.js v" + _this.requirejs.version + " & almond v" + _this.almondVersion + ".") + "\n" + text;
            return FileResource.save(_this.template.combinedFile, text);
          }
        };
        if (rjsConfig.optimize = _this.optimize) {
          rjsConfig[_this.optimize] = _this[_this.optimize];
        } else {
          rjsConfig.optimize = "none";
        }
        if (l.deb(80)) {
          rjsConfig.logLevel = 0;
        }
        if (!_.isEmpty(_this.rjs)) {
          _.defaults(rjsConfig, _.clone(_this.rjs, true));
        }
        l.deb(40, "Executing requirejs.optimize (v" + _this.requirejs.version + ") / almond (v" + _this.almondVersion + ") with uRequire's 'build.js' = \n", _.omit(rjsConfig, ["wrap"]));
        rjsStartDate = new Date();
        return _this.requirejs.optimize(rjsConfig, function (buildResponse) {
          if (l.deb(40)) {
            l.debug("requirejs.optimize rjsConfig, (buildResponse)-> = ", buildResponse);
          }
          if (fs.existsSync(_this.template.combinedFile)) {
            l.ok("Combined file '" + _this.template.combinedFile + "' written successfully for build #" + _this.count + ", rjs.optimize took " + (new Date() - rjsStartDate) / 1000 + "secs .");
            if (!_.isEmpty(_this.bundle.modules_localNonNode_depsVars)) {
              if (!_this.watch.enabled || l.deb(50)) {
                l.verbose("\nDependencies: make sure the following `local` depsVars bindinds:\n", combinedTemplate.localDepsVars, "\n\nare available when combined script '" + _this.template.combinedFile + "' is running on:\n  a) nodejs: they should exist as a local `nodes_modules`.\n  b) Web/AMD: they should be declared as `rjs.paths` (and/or `rjs.shim`)\n  c) Web/Script: the binded variables (eg '_' or '$') must be\n     globally loaded (i.e `window.$`) BEFORE loading '" + _this.template.combinedFile + "'\n");
              }
            }
            return resolve();
          } else {
            return reject(new UError("Combined file '" + _this.template.combinedFile + "' NOT written - this should NOT have happened,\nas requirejs reported success. Check requirejs's build response:", { nested: buildResponse }));
          }
        }, function (error) {
          return reject(new UError("@requirejs.optimize error: Combined file '" + _this.template.combinedFile + "' NOT written. Some remedy:\n   a) Perhaps you have a missing dependeency ?\n   b) Is your *bundle.main = '" + _this.bundle.main + "'* properly defined ?\n      - 'main' is the name of your 'entry' module, that usually kicks off all other modules\n      - if not defined, it defaults to `bundle.name`, or 'index' or 'main' if any of those exist as files.\n   c) Check the reported error", { nested: error }));
        });
      };
    }(this));
  };
  Build.prototype.report = function () {
    var diffSize, interestingDepTypes, ref1, ref2, report;
    l.verbose("Report for `" + (this.bundle.name || "empty bundle.name") + "` target `" + this.target + "` build #" + this.count + ":");
    if (this.bundle.hasFullBuild === this.count || this.verbose) {
      interestingDepTypes = null;
    } else {
      if (!this.verbose) {
        interestingDepTypes = [
          "notFoundInBundle",
          "untrusted"
        ];
      }
    }
    if (this.template.name === "nodejs") {
      interestingDepTypes = ["notFoundInBundle"];
    }
    if (!_.isEmpty(report = this.bundle.reporter.getReport(interestingDepTypes))) {
      l.warn("\n \nDependency types report for `" + (this.bundle.name || "empty bundle.name") + "` target `" + this.target + "` build #" + this.count + ":\n", report);
    }
    l.verbose("Changed: " + _.size(this.changedResources) + " file resources of which " + _.size(this.changedModules) + " were modules.");
    if (((ref1 = this._copied) != null ? ref1[0] : void 0) || ((ref2 = this._copied) != null ? ref2[1] : void 0)) {
      l.verbose("Copied " + this._copied[0] + " files, Skipped copying " + this._copied[1] + " files.");
    }
    if (this.hasErrors) {
      if (diffSize = _.size(this.bundle.errorFiles) !== _.size(this.changedErrorFiles)) {
        l.er(_.size(this.changedErrorFiles) + " files with errors in this build.");
      }
      if (_.size(this.bundle.errorFiles)) {
        l.er(_.size(this.bundle.errorFiles) + " files with errors in bundle" + (diffSize ? "" : "/build") + ".\n", this.bundle.errorFiles);
      }
      return l.er("Build #" + this.count + " finished with " + _.size(this.errors) + " errors in " + (new Date() - this.startDate) / 1000 + "secs.");
    } else {
      return l.verbose("Build #" + this.count + " finished succesfully in " + (new Date() - this.startDate) / 1000 + "secs.");
    }
  };
  Build.prototype.printError = function (error, nesting) {
    var nested, ref1;
    if (nesting == null) {
      nesting = 0;
    }
    if (!error) {
      return l.er("printError: NO ERROR (" + error + ")");
    } else {
      nested = error.nested;
      delete error.nested;
      if (!error.printed) {
        l.er((nesting ? "nested" : "") + " #" + nesting + ":", (error != null ? (ref1 = error.constructor) != null ? ref1.name : void 0 : void 0) || "No error.constructor.name", "\n " + _.repeat("    ", nesting), _.isFunction(error.toString) ? error.toString() : error);
        error.printed = true;
        l.deb(100, "\n error.stack = \n", error.stack);
        if (nested) {
          return this.printError(nested, nesting + 1);
        }
      }
    }
  };
  Build.prototype.handleError = function (error) {
    this.printError(error);
    error || (error = new UError("Undefined or null error!"));
    if (indexOf.call(this.errors, error) < 0) {
      this.errors.push(error);
    }
    if (this["continue"] || this.watch.enabled) {
      return l.warn("Continuing despite of error due to `build.continue` || `build.watch`");
    } else {
      throw error;
    }
  };
  return Build;
}(_B.CalcCachedProperties);
_.extend(module.exports.prototype, {
  l: l,
  _: _,
  _B: _B
});

;