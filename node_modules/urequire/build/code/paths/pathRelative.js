// Generated by uRequire v0.7.0-beta.23 target: 'lib' template: 'nodejs'

var _ = require('lodash'),
    _B = require('uberscore'),
    UError = require('../utils/UError');

var l = new _B.Logger('uRequire/paths/pathRelative');

var pathRelative;
pathRelative = function (from, to, options) {
  var commonPath, finalPath, i, j, k, lastFrom, lastTo, len, len1, len2, part, path, ref, ref1, ref2;
  options || (options = {});
  if (options.assumeRoot) {
    from = "$/" + from;
    to = "$/" + to;
  }
  ref = function () {
    var i, len, ref, results;
    ref = [
      from,
      to
    ];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      path = ref[i];
      results.push(path.replace(/\\/g, "/").split("/"));
    }
    return results;
  }(), from = ref[0], to = ref[1];
  ref1 = function () {
    var i, len, ref1, results;
    ref1 = [
      from,
      to
    ];
    results = [];
    for (i = 0, len = ref1.length; i < len; i++) {
      path = ref1[i];
      results.push(function () {
        var j, len1, results1;
        results1 = [];
        for (j = 0, len1 = path.length; j < len1; j++) {
          part = path[j];
          if (part !== "" && part !== ".") {
            results1.push(part);
          }
        }
        return results1;
      }());
    }
    return results;
  }(), from = ref1[0], to = ref1[1];
  ref2 = [
    from,
    to
  ];
  for (i = 0, len = ref2.length; i < len; i++) {
    path = ref2[i];
    if (path.length === 0) {
      return null;
    }
  }
  commonPath = [];
  while ((lastFrom = from.shift()) === (lastTo = to.shift()) && (from.length > 0 || to.length > 0)) {
    commonPath.push(lastFrom);
  }
  finalPath = [];
  if (commonPath.length > 0 || lastFrom === lastTo) {
    if (lastFrom !== lastTo) {
      if (lastFrom) {
        from.unshift(lastFrom);
      }
      if (lastTo) {
        to.unshift(lastTo);
      }
      for (j = 0, len1 = from.length; j < len1; j++) {
        part = from[j];
        if (part !== "..") {
          finalPath.push("..");
        } else {
          if (finalPath.length > 0) {
            finalPath.pop();
          } else {
            if (commonPath.length > 0) {
              to.unshift(commonPath.pop());
            } else {
              return null;
            }
          }
        }
      }
      for (k = 0, len2 = to.length; k < len2; k++) {
        part = to[k];
        if (part !== "..") {
          finalPath.push("" + part);
        } else {
          if (finalPath[finalPath.length - 1] === "..") {
            finalPath.push("..");
          } else {
            finalPath.pop();
          }
        }
      }
    }
    if (options.dot4Current) {
      if (finalPath[0] !== "..") {
        finalPath.unshift(".");
      }
    }
    if (options.assumeRoot && finalPath[finalPath.length - 1] === "$") {
      finalPath.pop();
    }
    return finalPath.join("/");
  } else {
    return null;
  }
};
module.exports = pathRelative;

;