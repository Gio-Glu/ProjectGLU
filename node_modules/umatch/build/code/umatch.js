/**
* umatch http://github.com/anodynos/umatch/
*
* A `function(filename, specs)` thats checks if `'someFile.ext'` passes through an of Array of `minimatch` / `RegExp` / `callbacks` / `Array` (recursive) specs, with a negation/exclusion '!' flag for all.
* Version 0.2.1 - Compiled on 2014-11-13 05:11:12
* Repository git://github.com/anodynos/umatch
* Copyright(c) 2014 Agelos Pikoulas <agelos.pikoulas@gmail.com>
* License MIT http://www.opensource.org/licenses/mit-license.php
*/

// Generated by uRequire v0.7.0-beta9 - template: 'nodejs' 
(function () {
  
var __isAMD = !!(typeof define === 'function' && define.amd),
    __isNode = (typeof exports === 'object'),
    __isWeb = !__isNode;

var _ = require('lodash');

var VERSION = '0.2.1'; // injected by urequire-rc-inject-version

var minimatch, umatch;
minimatch = require("minimatch");
umatch = module.exports = function (filename, specs) {
  var agreement, agrees, excludeIdx, finalAgree, idx, _i, _len;
  finalAgree = false;
  if (!_.isArray(specs)) {
    specs = [specs];
  }
  for (idx = _i = 0, _len = specs.length; _i < _len; idx = ++_i) {
    agreement = specs[idx];
    agrees = function () {
      if (_.isString(agreement)) {
        if (agreement[0] === "!") {
          if (agreement === "!") {
            excludeIdx = idx + 1;
          } else {
            excludeIdx = idx;
          }
          return minimatch(filename, agreement.slice(1));
        } else {
          return minimatch(filename, agreement);
        }
      } else {
        if (_.isRegExp(agreement)) {
          return !!filename.match(agreement);
        } else {
          if (_.isFunction(agreement)) {
            return agreement(filename);
          } else {
            if (_.isArray(agreement)) {
              return umatch(filename, agreement);
            } else {
              if (!(_.isUndefined(agreement) || _.isNull(agreement))) {
                throw new TypeError("umatch: invalid file spec type `" + typeof agreement + "` with value `" + agreement + "`");
              }
            }
          }
        }
      }
    }();
    if (agrees === true) {
      if (idx === excludeIdx) {
        finalAgree = false;
      } else {
        finalAgree = true;
      }
    }
  }
  return finalAgree;
};
umatch.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "{NO_VERSION}";


}).call(this)